# 概述
- 锁应用遇到的问题
	- 死锁
		- 分配带来的矛盾问题，一份无法等额分配给两个人
		- 检测

# 分类
- 范围划分
    - 表锁 
	    - 避免其他的客户端会话在指定时间内访问同一张表
		    - 没有表锁的会话，会一直等待表的释放
	    - 分类
		    - 自增锁
				- 如果表中存在自增字段，MySQL会自动维护一个自增锁
		- 操作
			- LOCK TABLES table_name [READ | WRITE]
    - 行锁
	    - 等待行锁超时
		    - 产生
			    - 增删改同时操作一行时，MySQL会将该行锁定，只有得到锁权限的操作才能修改该条记录
	    - 分类一
	        - 共享锁(读锁)
		        - 允许事务读一行记录
	        - 互斥锁(写锁)
		        - 允许事务更新或删除一行记录
		        - Demo
			        - BEGIN;
						- SELECT name,sleep(10) FROM tn_user WHERE id = 1 FOR UPDATE
						- UPDATE tn_user SET name = 'sss' WHERE id = 1
					- COMMIT;
		- 分类二			
			- 索引记录
				- 记录锁
					- 索引记录上的锁
				- 间隙锁	
					- 索引记录之间，或者索引记录之外的锁
					- 
				- 临键锁(next-key)
				    - 
					- 记录锁之前的间隙锁，和记录锁的组合					
	- 多粒度锁
	    - 意向锁
			- 允许同时存在表锁和行锁，多颗粒度
			- 分类
				- IS，表中的行单独设置共享锁
				- IX，表中的行单独设置互斥锁	
- 读写
	- 读锁
		- 无论是否有读锁，所有的会话都可以访问
		- 拥有读锁的会话，只能从这张表读数据，不能写，其他的会话也不能写
		- 其他会话的写操作会进入写状态，直到读锁释放
	- 写锁
		- 拥有锁的会话可以读写这张表，其他会话不能对这张表进行读写
- 特点
	- 排它锁		
		- 当对某行记录添加排它锁
			- 在添加锁的请求执行期间
				- 别的请求无法update/delete该记录
				- 但可以查询
- 两种不同的实现事务锁
	- 悲观锁
	    - 缺点
		    - 资源从它第一次被访问时就锁上，直到事务结束
			    - 对其它事务不可访问
		- 锁以一种安全失败的方式被应用   
			- 当访问一个被上锁的资源，当前事务会被延迟或者回滚 

	- 乐观锁
		- 当一个资源第一次被访问时，资源实际上被没有被锁	
			- 取代地是，当资源本该被悲观锁定方法锁定的状态被保存
		- 其它的事务可以并发地访问	资源并且冲突变化的可能性是可能的
		- 在提交时间，当资源在一个持久存储里被更新的时候，资源的状态再一次从存储里读取
			- 并且和资源第一次被访问时保存的状态比较
			- 如果两个状态不同，一个更新冲突产生，事务将会被回滚				